\newcommand\tab[1][1cm]{\hspace*{#1}}
\section{Эволюционный алгоритм 1+1.}

\textbf{Как сделать RLS глобальным оптимизатором?}\\
В этом случае необходимо доказать, что оптимум является глобальным. \\
- Сделать мутацию глобальной, но локальной с большой вероятностью (чтобы мутация охватывала все возможные значения)\\
- Пример для задачи нахождения строки ZZZZ...Z \\
-Мутация: замена каждой буквы на случайную с вероятностью p = 1/N - Матожидание числа замененных букв: ровно 1 \\
- Каждая строка может быть превращена в каждую с ненулевой вероятностью \\
Мутация становится псевдослучайной.\\
function Next(x)  \\
y $\leftarrow$ RandOMMutatIOn(x)  \\
\tab {if f (y) $\ge$ f (x) then} \\ 
\tab \tab \text{return y } \\
\tab \text{end if } \\
\tab \text{return x}  \\
\text{end function} \\
\\
\textbf{«Стандартный» оператор мутации}\\
Над строками длиной N: заменить каждый символ с вероятностью 1/N \\

То же самое, что: \\
- Выбрать число замен $l  B(N,1/N)$, где B — биномиальное распределение  \\
- Выбрать случайное подмножество индексов размера l и заменить там символы (Сначала генерируем индексы, а потом заменяем индексы на символы, делая нашу мутацию более похожей на глобальную)\\
\\
\textbf{Преимущества: \\}
 - Легко реализовать \\
 - Глобальный: любая строка получается из любой с ненулевой вероятностью (Нет повторения строк) \\
\\
\textbf{Недостатки: \\}
 - Вероятность заменить k символов убывает экспоненциально с k (Чем больше размер строки, тем меньше вариативность мутаций)\\
\\
\textbf{Оператор мутации по степенному закону \\}
Стандартный вариант \\
- Выбрать число $c \le [1..N]$ с вероятностью, пропорциональной $c ^ {- \beta}$ , где $\beta \le (1;2)$ — константный параметр \\
- Заменить каждый символ с вероятностью $c/N$\\ 
\\
Альтернативный  упрощенный  вариант \\
- Выбрать c как описано выше, далее заменять c символов на случайно выбранных позициях \\
- Основные свойства те же \\
\\
Преимущества: \\
- В среднем все еще заменяет O(1) символов\\
- Может заменить много символов с гораздо большей (полиномиально убывающей) вероятностью \\
- Работает значительно лучше на многих сложных задачах \\
«Быстрый» (fast) эволюционный алгоритм (1 + 1)\\
\\
\textbf{Ускорение движения по «градиенту»} \\
- Создавать больше потомков, выбирать лучшего \\
- Лучший потомок заменяет родителя, если он лучше \\
По сути мы получаем, что с каждой генераций значения функции применимости улучшаются для всего множества. \\
Есть ограничения, что при равенстве потомков и родителей функция применимости становится бесполезной. \\
Нужно ставить ограничение на число итераций.\\
\\
function Next(x)  \\
\tab $y_i$ $\leftarrow$ $RandOMMutatIOn(x)$ \text{для каждого} $i$ $\in [1;\lambda]$  \\
\tab $y = y_1$   \\
\tab for i $\in$ $[2;\lambda]$ do  \\
\tab \tab if f ($y_i$) > f ($y$) then  \\
\tab \tab \tab $y$ $\leftarrow$ $y_i$   \\
\tab \tab end if \\ 
\tab end for  \\
\tab if f (y) $\le$ f (x) then \\
\tab \tab return y  \\
\tab end if  \\
\tab return x  \\
end function \\
\\
\textbf{Вариант с запятой: родитель никогда не выживает}\\
- Создавать больше потомков, выбирать лучшего\\ 
- Лучший потомок заменяет родителя, если он не хуже \\
\\
function Next(x)  \\
\tab $y_i$ $\leftarrow$ RandOMMutatIOn(x) \text{ для каждого i} $\in [1;\lambda]$  \\
\tab y = $y_i$  \\
\tab for i $\in [2;\lambda]$ do  \\
\tab \tab if f ($y_i$) > f (y) then  \\
\tab \tab \tab y $\leftarrow$ $y_i$   \\
\tab \tab end if  \\
\tab end for  \\
\tab return y  \\
end function \\
\\
\textbf{Используем локальный поиск, перезапускаемся при его окончании \\}
\\
x $\leftarrow$ случайное решение  \\
b $\leftarrow$ x \\ 
while b недостаточно хорошее и еще есть время do \\
\tab y $\leftarrow$ LOCALSeaRCh(x)  \\
\tab if f (y) > f (b) then  \\
\tab \tab b $\leftarrow$ y  \\
\tab end if  \\
\tab x $\leftarrow$ случайное решение  \\
end while\\
return b\\

(Такой подход сработает не на всех пространствах, то есть не гарантируется, что в другой области не найдется более глобального оптимума)
