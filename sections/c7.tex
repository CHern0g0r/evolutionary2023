\newcommand\tab[1][1cm]{\hspace*{#1}}
\section{Эволюционный алгоритм 1+1.}

\textbf{Как сделать RLS глобальным оптимизатором?}\\
В этом случае необходимо доказать, что оптимум является глобальным.

Сделать мутацию глобальной, но локальной с большой вероятностью (чтобы мутация охватывала все возможные значения)

Пример для задачи нахождения строки ZZZZ...Z:
\begin{itemize}
    \item Мутация: замена каждой буквы на случайную с вероятностью p = 1/N
    \item Матожидание числа замененных букв: ровно 1.
    \item Каждая строка может быть превращена в каждую с ненулевой вероятностью
    \item Мутация становится псевдослучайной.
\end{itemize}

function Next(x)  \\
y $\leftarrow$ RandomMutation(x)  \\
\tab {if f (y) $\ge$ f (x) then} \\ 
\tab \tab \text{return y } \\
\tab \text{end if } \\
\tab \text{return x}  \\
\text{end function} \\
\\
\textbf{«Стандартный» оператор мутации}\\
Над строками длиной N: заменить каждый символ с вероятностью 1/N \\

То же самое, что:
\begin{itemize}
    \item Выбрать число замен $l \sim B(N,1/N)$, где B — биномиальное распределение  
    \item Выбрать случайное подмножество индексов размера l и заменить там символы
    (Сначала генерируем индексы, а потом заменяем индексы на символы, делая нашу
    мутацию более похожей на глобальную)
\end{itemize}

\textbf{Преимущества: \\}
 - Легко реализовать \\
 - Глобальный: любая строка получается из любой с ненулевой вероятностью (Нет повторения строк) \\
\\
\textbf{Недостатки: \\}
 - Вероятность заменить k символов убывает экспоненциально с k (Чем больше размер строки, тем меньше вариативность мутаций)\\
\\
\textbf{Оператор мутации по степенному закону \\}
Стандартный вариант \\
- Выбрать число $c \le [1..N]$ с вероятностью, пропорциональной $c ^ {- \beta}$ , где $\beta \in (1;2)$ — константный параметр \\
- Заменить каждый символ с вероятностью $c/N$\\ 
\\
Альтернативный  упрощенный  вариант \\
- Выбрать c как описано выше, далее заменять c символов на случайно выбранных позициях \\
- Основные свойства те же \\
\\
Преимущества: \\
- В среднем все еще заменяет O(1) символов\\
- Может заменить много символов с гораздо большей (полиномиально убывающей) вероятностью \\
- Работает значительно лучше на многих сложных задачах

\subsection*{$(1+\lambda)$}

\textbf{Ускорение движения по «градиенту»} \\
- Создавать больше потомков, выбирать лучшего \\
- Лучший потомок заменяет родителя, если он лучше

По сути мы получаем, что с каждой генераций значения функции применимости улучшаются для всего множества. \\
Есть ограничения, что при равенстве потомков и родителей функция применимости становится бесполезной. \\
Нужно ставить ограничение на число итераций.\\
\\
function Next(x)  \\
\tab $y_i$ $\leftarrow$ $RandOMMutatIOn(x)$ \text{для каждого} $i$ $\in [1;\lambda]$  \\
\tab $y = y_1$   \\
\tab for i $\in$ $[2;\lambda]$ do  \\
\tab \tab if f ($y_i$) > f ($y$) then  \\
\tab \tab \tab $y$ $\leftarrow$ $y_i$   \\
\tab \tab end if \\ 
\tab end for  \\
\tab if f (y) $\le$ f (x) then \\
\tab \tab return y  \\
\tab end if  \\
\tab return x  \\
end function

\subsection*{$(1,\lambda)$}

\textbf{Вариант с запятой: родитель никогда не выживает}\\
- Создавать больше потомков, выбирать лучшего\\ 
- Лучший потомок заменяет родителя \\
\\
function Next(x)  \\
\tab $y_i$ $\leftarrow$ RandOMMutatIOn(x) \text{ для каждого i} $\in [1;\lambda]$  \\
\tab y = $y_i$  \\
\tab for i $\in [2;\lambda]$ do  \\
\tab \tab if f ($y_i$) > f (y) then  \\
\tab \tab \tab y $\leftarrow$ $y_i$   \\
\tab \tab end if  \\
\tab end for  \\
\tab return y  \\
end function

\subsection*{Restart Strategy}

\textbf{Используем локальный поиск, перезапускаемся при его окончании}
\\
x $\leftarrow$ случайное решение  \\
b $\leftarrow$ x \\ 
while b недостаточно хорошее и еще есть время do \\
\tab y $\leftarrow$ LOCALSeaRCh(x)  \\
\tab if f (y) > f (b) then  \\
\tab \tab b $\leftarrow$ y  \\
\tab end if  \\
\tab x $\leftarrow$ случайное решение  \\
end while\\
return b\\

(Такой подход сработает не на всех пространствах, то есть не гарантируется, что в другой области не найдется более глобального оптимума)
